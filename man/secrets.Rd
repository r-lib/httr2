% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/secret.R
\name{secrets}
\alias{secret_get_key}
\alias{secret_make_key}
\alias{secret_encrypt}
\alias{secret_decrypt}
\alias{secret_read_rds}
\alias{secret_write_rds}
\title{Secret management}
\usage{
secret_get_key(envvar)

secret_make_key()

secret_encrypt(x, key)

secret_decrypt(encrypted, key)

secret_read_rds(path, key)

secret_write_rds(x, path, key)
}
\arguments{
\item{envvar}{Name of environment variable where the key is stored.}

\item{x}{Object to encrypt. Must be a string for \code{secret_encrypt()}.}

\item{key}{Encryption key; this is the password that allows you to "lock"
and "unlock" the secret. A bare string is passed to \code{secret_get_key()}
to look up from in an env var; wrap a string in \code{I()} to treat it directly
as a key.}

\item{encrypted}{String to decrypt}

\item{path}{Path to \code{.rds} file}
}
\description{
httr2 provides a handful of functions designed for working with confidential
data. These are useful because testing packages that use httr2 often
requires some confidential data that needs to be available for testing,
but should not be available to package users.
\itemize{
\item \code{secret_encrypt()} and \code{secret_decrypt()} work with individual strings
\item \code{secret_read_rds()} and \code{secret_write_rds()} work with \code{.rds} files
\item \code{secret_get_key()} retrieves a key from an environment variable.
When used inside of testthat, it will automatically \code{\link[testthat:skip]{testthat::skip()}} the
current test if the env var isn't set.
\item \code{secret_make_key()} generates a random key.
}
}
\section{Basic workflow}{
\enumerate{
\item Use \code{secret_make_key()} to generate a password. Make this available
as an env var by adding a line to your \code{.Renviron}.
\item Retrieve the key uss \code{secret_get_key()} and use it to encrypt data
with \code{secret_encrypt()} (for strings) and \code{secret_write_rds()} (for
more complicated data structures).
\item In your tests, access the encrypted data by first retrieving the key
with \code{secret_get_key()}, and then decrypting the data with
\code{secret_decrypt()} or \code{secret_read_rds()}. You might want to write
a couple of wrappers to reduce the amount of boilerplate in your
tests.
\item If you push this code to your CI server, it will already "work" because
\code{secret_get_key()} will automatically skip tests when the env var isn't
set. To make the tests actually run, you'll need to set the env var using
whatever tool your CI system provides for setting env vars. Make sure
to carefully inspect the test output to check that the skips have gone
away.
}
}

\examples{
key <- secret_make_key()

path <- tempfile()
secret_write_rds(mtcars, path, key = key)
secret_read_rds(path, key)

# While you can manage the key explicitly in a variable, it's much
# easier to store in an env variable. In real life, you should NEVER
# use `Sys.setenv()` to create this env var (instead using .Renviron or
# similar) but I need to do it here since it's an example
Sys.setenv("MY_KEY" = key)

x <- secret_encrypt("This is a secret", "MY_KEY")
x
secret_decrypt(x, "MY_KEY")
}
