% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iterate.R
\name{req_perform_iteratively}
\alias{req_perform_iteratively}
\title{Perform requests iteratively, generating new requests from previous responses}
\usage{
req_perform_iteratively(
  req,
  next_req,
  path = NULL,
  max_reqs = 20,
  progress = TRUE
)
}
\arguments{
\item{req}{A \link{request}.}

\item{next_req}{A function that takes the previous response (\code{resp}) and
request (\code{req}) and returns a \link{request} for the next page or \code{NULL} if
the iteration should terminate.}

\item{path}{Optionally, path to save body of request. This should be
a glue string that uses \code{{i}} to distinguish different requests.
Useful for large responses because it avoids storing the response in
memory.}

\item{max_reqs}{The maximum number of requests to perform. Use \code{Inf} to
perform all requests until \code{next_req()} returns \code{NULL}.}

\item{progress}{Display a progress bar? Use \code{TRUE} to turn on a basic
progress bar, use a string to give it a name, or see \link{progress_bars} to
customise it in other ways.}
}
\value{
A list of \code{\link[=response]{response()}}s.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

\code{req_perform_iteratively()} iteratively generates and performs requests,
using a callback function, \code{next_req}, to define the next request based on
the current request and response. You will probably want to it pair with an
\link[=iterate_with_offset]{iteration helper} and use a
\link[=resps_combine]{multi-response handler} to process the result.
}
\examples{
req <- request(example_url()) |>
  req_url_path("/iris") |>
  req_throttle(10) |>
  req_url_query(limit = 5)

resps <- req_perform_iteratively(req, iterate_with_offset("page_index"))

resps |> resps_combine(function(resp) {
  data <- resp_body_json(resp)$data
  data.frame(
    Sepal.Length = sapply(data, `[[`, "Sepal.Length"),
    Sepal.Width = sapply(data, `[[`, "Sepal.Width"),
    Petal.Length = sapply(data, `[[`, "Petal.Length"),
    Petal.Width = sapply(data, `[[`, "Petal.Width"),
    Species = sapply(data, `[[`, "Species")
  )
})
}
