% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/paginate.R
\name{req_perform_iteratively}
\alias{req_perform_iteratively}
\alias{iterate_next_request}
\title{Perform requests iteratively, generating new requests from previous responses}
\usage{
req_perform_iteratively(req, max_pages = 20L, progress = TRUE)

iterate_next_request(req, parsed)
}
\arguments{
\item{req}{A \link{request}.}

\item{max_pages}{The maximum number of pages to request.}

\item{progress}{Display a progress bar? Use \code{TRUE} to turn on a basic progress
bar, use a string to give it a name, or see \link{progress_bars} for more details.}

\item{parsed}{The response parsed by the argument \code{parse_resp} of \code{\link[=req_paginate]{req_paginate()}}.}
}
\value{
The result of \code{vec_c()}ing together the \code{data} fields that were
extracted by the \code{parse_resp} argument of \code{\link[=req_paginate]{req_paginate()}}.
If \code{parse_resp} is not specified, it will be a list of the raw responses.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}
\itemize{
\item \code{req_perform_iteratively()} requests all pages for an iterated request and
returns a list of responses.
\item \code{iterate_next_request()} generates the request for the next page for an
iterated response, or \code{NULL} if there are no more pages to return.
}
}
\examples{
page_size <- 40

req_flowers <- request(example_url()) \%>\%
  req_url_path("/iris") \%>\%
  req_url_query(limit = page_size) \%>\%
  req_paginate_page_index(
    page_index = function(req, page) {
      req \%>\% req_url_query(page_index = page)
    },
    parse_resp = function(resp) {
      parsed <- resp_body_json(resp)
      results <- parsed$data
      data <- data.frame(
        Sepal.Length = sapply(results, `[[`, "Sepal.Length"),
        Sepal.Width = sapply(results, `[[`, "Sepal.Width"),
        Petal.Length = sapply(results, `[[`, "Petal.Length"),
        Petal.Width = sapply(results, `[[`, "Petal.Width"),
        Species = sapply(results, `[[`, "Species")
      )

      list(data = data, count = parsed$count)
    },
    n_pages = function(parsed) {
      total <- parsed$count
      ceiling(total / page_size)
    }
  )

req_perform_iteratively(req_flowers)
}
