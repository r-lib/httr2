---
title: "Wrapping APIs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Wrapping APIs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

A common use for httr2 is wrapping up a useful API and exposing it in an R package where each API endpoint (i.e. a URL with parameters) becomes an R function with documented arguments.
This vignette will show you how, starting with a very simple API that doesn't need authentication, then slowly working up in complexity.
Along the way, you'll learn about how to:

-   Expose important details from HTTP errors in R errors.

-   Handle various types of authentication.

-   Consistently throttle the rate of requests or dynamically respond to rate limiting headers sent by the server.

I assume you're familiar with the basics of building a package.
If not, you might want to reading the "[The Whole Game](https://r-pkgs.org/whole-game.html)" chapter of [R packages](https://r-pkgs.org) first.

```{r setup}
library(httr2)
```

## Faker API

```{r, include = FALSE}
# Seems to return 500s from time-to-time, so avoid any problems
# by only evaluating other chunks if a simple request succeeds.
faker_status_images <- request("https://fakerapi.it/api/v1") %>% 
  req_url_path_append("images") %>% 
  req_error(is_error = ~ FALSE) %>% 
  req_perform() %>% 
  resp_status()
faker_status_persons <- request("https://fakerapi.it/api/v1") %>% 
  req_url_path_append("persons") %>% 
  req_error(is_error = ~ FALSE) %>% 
  req_perform() %>% 
  resp_status()

faker_ok <- faker_status_images < 400 && faker_status_persons < 400
```

We'll start with a very simple API, [faker API](https://fakerapi.it/en){.uri}, which provides a collection of techniques for generating fake data.
Before we start writing the sort of functions that you might put in a package, we'll perform a request just to see how the basics work:

```{r, eval = faker_ok}
# We start by creating a request that uses the base API url
req <- request("https://fakerapi.it/api/v1")
resp <- req %>% 
  # Then we add on the images path
  req_url_path_append("images") %>% 
  # Add set _width and _quantity query parameters
  req_url_query(`_width` = 380, `_quantity` = 1) %>% 
  req_perform()

# The result comes back as JSON
resp %>% resp_body_json() %>% str()
```

### Errors

It's always worth a little early experimentation to see if we get any useful information from errors.
The httr2 details get in your way here because if you retrieve an unsuccessful HTTP response, you automatically get an error that prevents you from further inspecting the body:

```{r, error = TRUE, eval = faker_ok}
req %>% 
  req_url_path_append("invalid") %>% 
  req_perform()
```

You can access the failed response with `last_response()`:

```{r, eval = faker_ok}
resp <- last_response()
resp %>% resp_body_json()
```

It doesn't look like there's anything useful there so I'll double check the headers:

```{r, eval = faker_ok}
resp %>% resp_headers()
```

It doesn't look like we're getting any more useful information, so we can leave the `req_error()` default as is.
We'll have another go later with an API that does provide more details.

### User agent

When making a package that calls an API it's considered polite to set a user agent, so that if your app accidentally does something horribly wrong, the developers of the website can figure out who to reach out to.
You can do this with the `req_user_agent()` function:

```{r, eval = faker_ok}
req %>%
  req_user_agent("httr2 (http://httr2.r-lib.org)") %>% 
  req_dry_run()
```

### Core request function

Once you've successful made a few requests, it's worth seeing if you can figure out the general pattern so you can wrap it up into a function that will become the core of your package.

For faker, I spent a little with the [documentation](https://fakerapi.it/en#basic-usage) noting some commonalities:

-   Every URL is of the form [`https://fakerapi.it/api/v1`](https://fakerapi.it/api/v1)`/{resource}`, and data is passed to the resource with query parameters.
    All parameters start with `_`.

-   Every resource has three common query parameters: `_locale`, `_quantity`, and `_seed` which have default values of `en_US`, `1` and `null` respectively.

-   All endpoints return JSON data.

This lead me to construct the following function:

```{r, eval = faker_ok}
faker <- function(resource, ..., quantity = 1, locale = "en_US", seed = NULL) {
  params <- list(
    ...,
    quantity = quantity,
    locale = locale,
    seed = seed
  )
  names(params) <- paste0("_", names(params))
  
  request("https://fakerapi.it/api/v1") %>% 
    req_url_path_append(resource) %>% 
    req_url_query(!!!params) %>% 
    req_user_agent("httr2 (http://httr2.r-lib.org)") %>% 
    req_perform() %>% 
    resp_body_json()
}

str(faker("images", width = 300))
```

There's one trick to notice here --- `req_url_query()` uses [dynamic dots](https://rlang.r-lib.org/reference/dyn-dots.html), so we can use `!!!` to convert (e.g.) `` req_url_query(req, !!!list(`_quantity` = 1, `_locale` = "en_US") `` into `` req_url_query(req, `_quantity` = 1, `_locale` = "en_US") ``.

Here I've decided to make my central function perform the request and parse the result.
If the API you are wrapping is more variable, you may want to return a request object that the caller can modify before fetching the response.

### Wrapping individual endpoints

`faker()` is quite general --- it's a good tool for the package developer because you can read the faker documentation and translate it to a function call.
But it's not very friendly for the package user who might not know anything about web APIs.
So typically the next step in the process is to wrap up some individual endpoints with their own functions.

For example, let's take the persons endpoint which has three additional parameters: `gender` (male or female), `birthday_start`, and `birthday_end`.
A simple wrapper would start something like this:

```{r, eval = faker_ok}
faker_person <- function(gender = NULL, birthday_start = NULL, birthday_end = NULL, quantity = 1, locale = "en_US", seed = NULL) {
  faker(
    "persons",
    gender = gender,
    birthday_start = birthday_start,
    birthday_end = birthday_end,
    quantity = quantity,
    locale = locale,
    seed = seed
  )  
}
str(faker_person("male"))
```

We could make it more user friendly by checking the input types, and returning the result as a tibble.
I did a quick and dirty conversion using purrr; depending on your needs you could use base R code or `tidyr::hoist()`.

```{r, eval = faker_ok}
library(purrr)

faker_person <- function(gender = NULL, birthday_start = NULL, birthday_end = NULL, quantity = 1, locale = "en_US", seed = NULL) {
  if (!is.null(gender)) {
    gender <- match.arg(gender, c("male", "female"))
  }
  if (!is.null(birthday_start)) {
    if (!inherits(birthday_start, "Date")) {
      stop("`birthday_start` must be a date")
    }
    birthday_start <- format(birthday_start, "%Y-%m-%d")
  }
  if (!is.null(birthday_end)) {
    if (!inherits(birthday_end, "Date")) {
      stop("`birthday_end` must be a date")
    }
    birthday_end <- format(birthday_end, "%Y-%m-%d")
  }
  
  json <- faker(
    "persons",
    gender = gender,
    birthday_start = birthday_start,
    birthday_end = birthday_end,
    quantity = quantity,
    locale = locale,
    seed = seed
  )  
  
  tibble::tibble(
    firstname = map_chr(json$data, "firstname"),
    lastname = map_chr(json$data, "lastname"),
    email = map_chr(json$data, "email"),
    gender = map_chr(json$data, "gender")
  )
}
faker_person("male", quantity = 5)
```

The next steps would be to export and document this function; but I'll leave that up to you.

## NYTimes Books API

```{r include = FALSE}
has_auth <- secret_has_key("HTTR2_KEY") && 
  # Don't run in R CMD check on GHA
  identical(Sys.getenv("RSPM"), "")
knitr::opts_chunk$set(eval = has_auth)
```

Next we'll take a look at the NYTimes [Books API](https://developer.nytimes.com/docs/books-product/1/overview). It requires a very simple authentication with an API key that's included in every request.
When you're wrapping an API that has a key you're going to face two struggles:

-   How do you test your package without sharing your key with the whole world?

-   How do you allow your users to supply their own key, without having to pass it to every function?

I'll start by tackling the first problem because otherwise there's no way for me to show how the API works in this vignette ðŸ˜ƒ.
We'll come back to the second at the very end of this section, because it's easiest to tackle once we have a function in place.

### Encrypting secrets

httr2 provides the `secret_decrypt()` and `secret_decrpyt()` functions that use asymmetric cryptography.
To use them you need to first create a "key" that's used to lock and unlock the secrets.
The best key is random because there's no way for anyone to guess it.
httr2 provides `secret_make_key()` to make a secure key for you:

```{r}
secret_make_key()
```

(Don't copy and paste this key; run `secret_make_key()` yourself to make your own personal key.)

Now you need to make this key available in the places were you want to unlock the secrets.
httr2 provides tools to retrieve keys from environment variables because this is a common way of communicating these sort of secrets.
So start by opening your `.Renviron` (e.g. with `usethis::edit_r_environ()`) and add a line like:

    YOURPACKAGE_KEY=key_that_you_generated_above

Another place you'll probably want to provide the key is in your Github actions.
This is a two step process:

1.  Add the key to your [repository secrets](https://docs.github.com/en/actions/reference/encrypted-secrets).

2.  Share the secret with the workflows that need it by adding a line to the appropriate workflow:

    ``` yaml
        env:
          HTTR2_KEY: ${{ secrets.HTTR2_KEY }}
    ```

    You can see how httr2 does it in <https://github.com/r-lib/httr2/blob/master/.github/workflows/R-CMD-check.yaml>.

Now you can encrypt your API key and store it in your tests --- there's no way for anyone to decrypt it unless they have your key.

```{r}
x <- secret_encrypt("my-secret", "HTTR2_KEY")
x
secret_decrypt(x, "HTTR2_KEY")
```

So now you can understand how the following code works:

```{r}
my_key <- secret_decrypt("4Nx84VPa83dMt3X6bv0fNBlLbv3U4D1kHM76YisKEfpCarBm1UHJHARwJHCFXQSV", "HTTR2_KEY")
```

Since most people won't have this key, n the source of this vignette I also check whether or not it's available with `has_auth <- secret_has_key("HTTR2_KEY")`, then use `knitr::opts_chunk(eval = has_auth)` so that the code is only run when possible.

When `secret_decrypt()` is run in tests, it will automatically skip the test if the key isn't found.
That means your tests will automatically pass on CRAN.

### Security considerations

Note that including an API key in a query is a relatively insecure; if an API uses it, its typically because the key is relatively easy to create or gives relatively few privileges.
Here it only takes a couple of minutes to generate your own NYTimes API key, so there's little incentive for someone to try and steal yours.

The main problem of storing credentials in the url is that it's easily revealable, because httr2 makes no efforts to redact confidential information stored in query parameters.
This means it's relatively easy to leak your key if you use `req_perform(verbose = 1)`, `req_dry_run()`, or even just print the request object.

All in all, this mean you need to be a little cautious if you need to get help with a reprex; you'll need to manually redact the key.

### Basic request

Now lets perform a test request and look at the response:

```{r}
resp <- request("https://api.nytimes.com/svc/books/v3") %>% 
  req_url_path_append("/reviews.json") %>% 
  req_url_query(`api-key` = my_key, isbn = 9780307476463) %>% 
  req_perform()
resp
```

Like most modern APIs, this one returns the results as JSON:

```{r}
resp %>% 
  resp_body_json() %>% 
  str()
```

Before we start wrapping this up into a function lets consider what happens with errors.

### Error handling

What happens if there's an error?
For example, if we deliberately supply an invalid key:

```{r, error = TRUE}
resp <- request("https://api.nytimes.com/svc/books/v3") %>% 
  req_url_path_append("/reviews.json") %>% 
  req_url_query(`api-key` = "invalid", isbn = 9780307476463) %>% 
  req_perform()
```

To see if there's any extra useful information we can again suppress the default error and inspect the result:

```{r, error = TRUE}
resp <- request("https://api.nytimes.com/svc/books/v3") %>% 
  req_url_path_append("/reviews.json") %>% 
  req_url_query(`api-key` = "invalid", isbn = 9780307476463) %>% 
  req_error(is_error = ~ FALSE) %>% 
  req_perform()
resp
resp %>% resp_body_json()
```

It looks like there's some useful additional info in the `faultstring`:

```{r}
resp %>% resp_body_json() %>% .$fault %>% .$faultstring
```

To add that information to future errors we can use the `info` argument to `req_error()`.
This should be a function that takes a response and returns a character vector of additional information to include in the error.
Once we do that and re-fetch the request, we see the additional information displayed in the R error:

```{r, error = TRUE}
resp <- request("https://api.nytimes.com/svc/books/v3") %>% 
  req_url_path_append("/reviews.json") %>% 
  req_url_query(`api-key` = "invalid", isbn = 9780307476463) %>% 
  req_error(info = function(resp) {
    resp %>% resp_body_json() %>% .$fault %>% .$faultstring
  }) %>% 
  req_perform()
```

### Rate limits

Another common source of errors is rate-limiting --- this is used by many servers to prevent one unruly client consuming too many resources.
The [frequently asked questions](https://developer.nytimes.com/faq#a11) page describes the rate limits for the NYT APIs:

> Yes, there are two rate limits per API: 4,000 requests per day and 10 requests per minute.
> You should sleep 6 seconds between calls to avoid hitting the per minute rate limit.
> If you need a higher rate limit, please contact us at [code\@nytimes.com](mailto:code@nytimes.com){.email}.

Many APIs return additional information about how long to wait when the rate limit is exceeded (often using the `Retry-After` header).
So I deliberately violated the rate limit by quickly making 11 requests; unfortunately while the response was a standard 429 (Too many requests), it did not include any information about how long to wait in either the response body or the headers.
That means we can't use `req_retry()`, which automatically waits the amount of time the server requests.
Instead, we'll use `req_throttle()` to ensure we don't make more than 10 requests every 60s:

```{r}
req <- request("https://api.nytimes.com/svc/books/v3") %>% 
  req_url_path_append("/reviews.json") %>% 
  req_url_query(`api-key` = "invalid", isbn = 9780307476463) %>% 
  req_throttle(10 / 60)
```

By default, `req_throttle()` shares the limit across all requests made to to host (i.e. `api.nytimes.com`).
Since the docs suggest the rate limit applies per API, you might want to use the `realm` argument to be a bit more specific:

```{r}
req <- request("https://api.nytimes.com/svc/books/v3") %>% 
  req_url_path_append("/reviews.json") %>% 
  req_url_query(`api-key` = "invalid", isbn = 9780307476463) %>% 
  req_throttle(10 / 60, realm = "https://api.nytimes.com/svc/books")
```

### Wrapping it up

Putting together all the pieces above yields a function something like this:

```{r}
nytimes_books <- function(api_key, path, ...) {
  request("https://api.nytimes.com/svc/books/v3") %>% 
    req_url_path_append("/reviews.json") %>% 
    req_url_query(..., `api-key` = api_key) %>% 
    req_error(info = function(resp) {
      resp %>% resp_body_json() %>% .$fault %>% .$faultstring
    }) %>% 
    req_throttle(10 / 60, realm = "https://api.nytimes.com/svc/books") %>% 
    req_perform() %>% 
    resp_body_json()
}

drunk <- nytimes_books(my_key, "/reviews.json", isbn = "0316453382")
drunk$results[[1]]$summary
```

To finish this up for a real package, you'd want to:

-   Add explicit arguments and check that they're correct type.

-   Export and document the function.

-   Converted the nested list into a more user friendly data structure (probably a data frame with one row per review).

You'd also want to provide some convenient way for the user to supply their own API key.

### User supplied key

A good place to start is an environment variable, because environment variables are easy to set without typing anything in the console (which can get accidentally shared via your `.Rhistory`) and are easily set in automated processes.
Then you'd write a function to retrieve the API key, returning a helpful message if it's not found:

```{r}
get_api_key <- function() {
  key <- Sys.getenv("NYTIMES_KEY")
  if (identical(key, "")) {
    stop("No API key found, please supply with `api_key` argument or with NYTIMES_KEY env var")
  }
  key
}
```

Then you could modify `nytimes_books()` to use `get_api_key()` as the default value for `api_key`.
Since the argument is now optional, we can move it to end of the argument list, since it'll only be needed in exceptional circumstances.

```{r, eval = FALSE}
nytimes_books <- function(path, ..., api_key = get_api_key()) {
  ...
}
```

You might extend `get_api_key()` to also consult your encrypted key to make it easier to write tests:

```{r}
is_testing <- function() {
  identical(Sys.getenv("TESTTHAT"), "true")
}

testing_key <- function() {
  secret_decrypt("4Nx84VPa83dMt3X6bv0fNBlLbv3U4D1kHM76YisKEfpCarBm1UHJHARwJHCFXQSV", "HTTR2_KEY")
}

get_api_key <- function() {
  key <- Sys.getenv("NYTIMES_KEY")
  if (identical(key, "")) {
    if (is_testing()) {
      testing_key()
    } else {
      stop("No API key found, please supply with `api_key` argument or with NYTIMES_KEY env var")  
    }
  }
  key
}
```

## Github Gists API

Next we'll take a look at an API that can make changes, not just retrieve data: [GitHub's gist API](https://docs.github.com/en/rest/reference/gists).
This uses different HTTP methods to perform different actions, like creating, updating, and deleting gists.
But before we can get to those, lets handle authentication, rate-limiting, and errors.

### Authentication

The easiest way to authenticate with a GitHub API is to use a personal access token.
A token is an alternative to a username and password.
You have one username + password per site; you can have one token per use case.
This lets each use case have a minimal set of permissions, and you can easily revoke one token without affecting any other use case.

I created a personal access token specifically for this vignette that can only access gists, and as in the last example, stored an encrypted version in this vignette:

```{r}
token <- secret_decrypt("Guz59woxKoIO_JVtp2IzU3mFIU3ULtaUEa8xvvpYUBdVthR8jhxzc3bMZFhA9HL-ZK6YZudOI6g", "HTTR2_KEY")
```

If you want to run this vignette yourself, you'll need to create a new token in your [GitHub settings](https://github.com/settings/tokens); just make sure it includes the "gist" scope.

To authenticate a request with the token, we need to put it in the `Authorization` header with a ["token" prefix](https://docs.github.com/en/rest/overview/resources-in-the-rest-api#authentication):

```{r}
req <- request("https://api.github.com/gists") %>% 
  req_headers(Authorization = paste("token", token))

req %>% req_perform()
```

Because the authorization header usually contains secret information, httr2 automatically redacts it[^1]:

[^1]: Again, it's still possible to extract it with a little extra work but httr2 tries to help you avoid revealing it by accident.
    httr protects you from yourself, not from someone deliberately trying to find the secret.

```{r}
req
req %>% req_dry_run()
```

### Errors

Once you've got authentication working, it's always a good idea to work on errors next, since that will help you debug any failed requests.
In my experience APIs rarely do a good job of documenting their errors, so you'll often have to do a little experimentation.
Here I'll construct a deliberately malformed query and see what happens:

```{r, error = TRUE}
resp <- request("https://api.github.com/gists") %>% 
  req_url_query(since = "abcdef") %>% 
  req_headers(Authorization = paste("token", token)) %>% 
  req_perform()
```

As expected, I get an HTTP error.
But does the response contain any useful information?
Let's take a look:

```{r}
resp <- last_response()
resp
resp %>% resp_body_json()
```

That body looks pretty useful!
So let's write a function that extracts the data and formats it for presentation to the user:

```{r}
github_error_info <- function(resp) {
  body <- resp_body_json(resp)
  
  message <- body$message
  if (!is.null(body$documentation_url)) {
    message <- c(message, paste0("See docs at <", body$documentation_url, ">"))
  }
  message
}
github_error_info(resp)
```

Now I can pass this function to the `info` argument of `req_error()` and it will be automatically included in the error when a request fails:

```{r, error = TRUE}
request("https://api.github.com/gists") %>% 
  req_url_query(since = "yesterday") %>% 
  req_headers(Authorization = paste("token", token)) %>% 
  req_error(info = github_error_info) %>% 
  req_perform()
```

Notice that each element of the character vector produced by `gh_error_info()` becomes a bullet in the resulting error.

### Rate-limiting

While we're thinking about errors, it's useful to look at what happens if the requests are rate limited.
Luckily, GitHub consistently uses response headers to provide information about the remaining [rate limits](https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting).

```{r}
resp <- req %>% req_perform() 
resp %>% resp_headers("ratelimit")
```

We can teach httr2 about this so it can automatically wait for a reset if the rate limit is hit.
We need to define two functions.
The first tells us whether or not a response has a transient error, i.e. it's worth waiting and trying again.
For GitHub, when the rate limit is [exceeded](https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting), the response has a 403 status and a `X-RateLimit-Remaining: 0` header:

```{r}
github_is_transient <- function(resp) {
  resp_status(resp) == 403 && 
    resp_header(resp, "X-RateLimit-Remaining") == "0"
}
github_is_transient(resp)
```

Then we need a function tells how to long wait.
GitHub tells us the absolute time in seconds so we convert that to an offset:

```{r}
github_after <- function(resp) {
  time <- as.numeric(resp_header(resp, "X-RateLimit-Reset"))
  time - unclass(Sys.time())
}
github_after(resp)
```

We then pass functions to `req_retry()` so httr2 has all the information it needs to handle rate-limiting automatically:

```{r}
request("http://api.github.com") %>%
  req_retry(
    is_transient = github_is_transient,
    after = github_after,
    max_seconds = 60
  )
```

You also need to supply either `max_tries` or `max_seconds` in order to activate `req_retry()`.

### Wrapping it all up

Let's wrap up everything we've learned so far into a single function that creates a request:

```{r}
req_github <- function(token) {
  request("https://api.github.com/gists") %>% 
    req_headers(Authorization = paste("token", token)) %>% 
    req_error(info = github_error_info) %>% 
    req_retry(
      is_transient = github_is_transient,
      after = github_after
    )
}

# Check it works:
req_github(token) %>% 
  req_perform()
```

We'll use this as the basis to solve the next challenge: uploading a gist.

### Sending data

To [create a gist](https://docs.github.com/en/rest/reference/gists#create-a-gist) we need to send a `POST` request with a body that contains data encodedd as JSON.
httr2 provides one function that does both of these things: `req_body_json()`:

```{r}
req <- req_github(token) %>% 
  req_body_json(list(
    description = "This is my cool gist!",
    files = list(test.R = list(content = "print('Hi!')")),
    public = FALSE
  ))
req %>% req_dry_run()
```

Depending on the API you're wrapping, you might need to send data in a different way.
`req_body_form()` and `req_body_multipart()` make it easier to encode data in two other common forms.
If the API requires something different you can use `req_body_raw()`.

Typically, the API will return some useful data about the resource you've just created.
Here I'll extract the gist ID so we can use it in the next examples, culminating with deleting the gist so I don't end up with a bunch of duplicated gists ðŸ˜ƒ.

```{r}
resp <- req %>% req_perform()
id <- resp %>% resp_body_json() %>% .$id
id
```

### Changing a gist

Actually, that description wasn't very true and I want to change it.
To do so, I need to again send JSON encoded data, but this time I need to use the `PATCH` verb.
So after adding the data to request, I use `req_method()` to override the default method:

```{r}
req <- req_github(token) %>% 
  req_url_path_append(id) %>% 
  req_body_json(list(description = "This is a lame gist")) %>% 
  req_method("PATCH")
req %>% req_dry_run()
```

### Deleting a gist

Deleting a gist is similar, except we don't send any data, we just need to adjust the default method from `GET` to `DELETE`.

```{r}
req <- req_github(token) %>% 
  req_url_path_append(id) %>% 
  req_method("DELETE")
req %>% req_dry_run()
req %>% req_perform()
```

## OAuth

If the API provides access to a website where the user already has an account (think Twitter, Instagram, Facebook, Google, GitHub, etc), it's likely to use OAuth to allow you to authenticate on behalf of the user.
OAuth[^2] is an authentication framework that's designed so that you don't have to share your username and password with an app; instead the app asks for permission to use your account.
You've almost certainly used this before on the web; it's used in most cases where one website wants to use another website on your behalf.

[^2]: Here I'll only talk about OAuth 2.0 which is the only version in common use today.
    OAuth 1.0 is largely only of historical interest.

### Clients

The first step in working with any OAuth api is to create a client.
This involves you registering for a developer account on the APIs website and creating a new OAuth app.
The process varies from API to API, but at the end of it you'll get a client id and in most cases a client secret.

If the API provides a way to authenticate without the client secret, you should leave it out of your package.
But in most cases, you'll need to include the secret in the package.
You can use `obfuscate()` to hide the secret; this is not bulletproof but in most cases it'll be easier create a new client than try and steal yours.
It is unusual for an OAuth client to be able to do anything in its own right, so even if someone does steal your secret there's not much harm they can do with it (generally the worst they can do is use up your rate limits).

To obfuscate a secret, call `obfuscate()`:

```{r}
obfuscate("secret")
```

Then use the client id from the website along with the obfuscated secret to create a client.
The following code shows a GitHub OAuth app that I created specifically for this vignette:

```{r}
client <- oauth_client(
  id = "28acfec0674bb3da9f38",
  secret = obfuscated("J9iiGmyelHltyxqrHXW41ZZPZamyUNxSX1_uKnvPeinhhxET_7FfUs2X0LLKotXY2bpgOMoHRCo"),
  token_url = "https://github.com/login/oauth/access_token",
  name = "hadley-oauth-test"
)
```

You need to figure out the `token_url` from the [documentation](https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps).
I wish I could give good advice about how to find it ðŸ˜ž.

Note that if you print the client the secret is automatically redacted:

```{r}
client
```

### Flows

Once you have a client you need to use it with a **flow** in order to get a token.
OAuth provides a number of different "flows", the most common is the "authorisation code" flow, which is implemented by `req_oauth_auth_code()`.
You can try it out by running this code:

```{r, eval = FALSE}
token <- oauth_flow_auth_code(client, auth_url = "https://github.com/login/oauth/authorize")
```

This flow can't be used inside a vignette because it's designed specifically for interactive use: it will open a webpage on Github that requires you to interactively confirm it's ok for this app to use your GitHub account.

Other flows provide different ways getting the token:

-   `req_oauth_client_credentials()` is used to allow the client to perform actions on its own behalf (instead of on behalf of some other user).

-   `req_oauth_device()` uses the "device" flow which is designed for devices like TVs that don't have an easy way to enter data.
    It also works well from the console.

-   `req_oauth_bearer_jwt()` uses a JWT signed by a private key.

-   `req_oauth_password()` exchanges a user name and password for an access token.

-   `req_oauth_refresh()` works directly with a refresh token that you've got elsewhere.
    It's useful for testing.

There's one historically important OAuth flows that httr2 doesn't support: the implicit grant flow.
This is now [mostly deprecated](https://developer.okta.com/blog/2019/05/01/is-the-oauth-implicit-flow-dead) and was never a particularly good fit for native applications because it relies on a technique for returning the access token that only works inside a web browser.

When wrapping an API, you'll need to carefully read the documentation to figure out which flows are available.
Typically you'll want to use the auth code flow, but if it's not available you'll need to carefully consider the others.
An additional wrinkle is that many APIs don't implement the flow in exactly the same way as the spec.
If your initial attempt doesn't work, you're going to need to do some sleuthing.
This is going to be painful but unfortunately there's no way around it.
I recommend using `with_verbosity()` so you can see exactly what httr2 is sending to the server.
You'll then need to carefully compare this to the API documentation and play spot the difference.

### Tokens

The point of a flow is to get a token.
You can use `req_auth_bearer_token()` to authorise a request with the access token stored inside the token object:

```{r, eval = FALSE}
request("https://api.github.com/user") %>% 
  req_auth_bearer_token(token$access_token) %>% 
  req_perform() %>% 
  resp_body_json() %>%
  .$name
#> [1] "Hadley Wickham"
```

However, in most cases you won't want to do this, but instead allow httr2 to manage the whole process, by switching from `oauth_flow_{name}` to `req_oauth_{name}`:

```{r, eval = FALSE}
request("https://api.github.com/user") %>% 
  req_oauth_auth_code(client, auth_url = "https://github.com/login/oauth/authorize") %>% 
  req_perform() %>% 
  resp_body_json()
```

This is important because most APIs provide only a short-lived access token that needs to be regularly refreshed using a longer-lived refresh token.
httr2 will automatically refresh the token in two cases:

-   The token includes an expiry date that's in the past.

-   The request returns a 401 status code and

If the access token has expired, httr will automatically retry automatically refresh before the first request.
If the request errors with a 401 and `invalid_token` error in the `WWW-authenticate` header.

### Caching

By default, `req_oauth_auth_code()` and friends will cache the token in memory, so that multiple requests in the same session all use the same token.
In some cases, you may want to save the token so that it's automatically used across sessions.
This is easy to do (just set `cache_disk = TRUE` in `req_oauth_auth_code()`) but you need to carefully consider the consequences of saving the users credentials on disk.

httr2 does the best it can to save these credentials securely.
They are stored in a directory that should only be accessible to the current user, and in `.rds` format which is hard to read from tools other than R.
Nevertheless, saving

You can see which clients have cached tokens by looking in the cache directory used by httr:

```{r}
dir(rappdirs::user_cache_dir("httr2"), recursive = TRUE)
```

httr2 automatically deletes any cached tokens that are older than 30 days whenever it's loaded.
This means that you'll need to re-auth at least once a month, but prevents tokens for hanging around on disk long after you've forgotten you created them.
